import streamlit as st
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import time
import os

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Painel de Logs de Neg√≥cio - Soma API",
    page_icon="üìà",
    layout="wide"
)

# Caminho do banco de dados
DB_PATH = '/workspaces/opentelemetryexample/soma-api/target/soma_logs.db'

# Fun√ß√£o para carregar logs de neg√≥cio
@st.cache_data(ttl=5)
def load_business_logs():
    try:
        if not os.path.exists(DB_PATH):
            return pd.DataFrame(), f"Banco n√£o encontrado: {DB_PATH}"
            
        conn = sqlite3.connect(DB_PATH)
        
        query = """
        SELECT 
            id,
            operation_id,
            user_id,
            timestamp,
            hour_of_day,
            day_period,
            operation_type,
            input_values,
            result_value,
            execution_time_ms,
            trace_id,
            ip_address,
            status,
            message
        FROM business_logs 
        ORDER BY timestamp DESC
        """
        
        df = pd.read_sql_query(query, conn)
        conn.close()
        
        if not df.empty:
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            return df, "OK"
        else:
            return pd.DataFrame(), "Tabela business_logs vazia"
        
    except Exception as e:
        return pd.DataFrame(), f"Erro: {str(e)}"

# Fun√ß√£o para carregar estat√≠sticas por usu√°rio
@st.cache_data(ttl=5)
def load_user_stats():
    try:
        conn = sqlite3.connect(DB_PATH)
        
        query = """
        SELECT 
            user_id,
            COUNT(*) as total_operations,
            AVG(execution_time_ms) as avg_execution_time,
            SUM(result_value) as total_sum_results,
            MIN(timestamp) as first_operation,
            MAX(timestamp) as last_operation
        FROM business_logs 
        GROUP BY user_id
        ORDER BY total_operations DESC
        """
        
        df = pd.read_sql_query(query, conn)
        conn.close()
        
        return df
        
    except Exception as e:
        return pd.DataFrame()

# T√≠tulo principal
st.title("üìà Painel de Logs de Neg√≥cio - Soma API")
st.markdown("An√°lise detalhada das opera√ß√µes por usu√°rio e comportamento de uso")
st.markdown("---")

# Sidebar para controles
st.sidebar.header("‚öôÔ∏è Controles")
auto_refresh = st.sidebar.checkbox("üîÑ Auto-refresh (5s)", value=False)
limit_records = st.sidebar.slider("üìä Registros", 10, 100, 30)

# Filtros
st.sidebar.subheader("üîç Filtros")
selected_users = st.sidebar.multiselect("Usu√°rios:", options=[], default=[])
selected_periods = st.sidebar.multiselect("Per√≠odos do dia:", 
                                         options=["MORNING", "AFTERNOON", "EVENING", "NIGHT"],
                                         default=["MORNING", "AFTERNOON", "EVENING", "NIGHT"])

if auto_refresh:
    time.sleep(5)
    st.rerun()

# Carregar dados
df_logs, status = load_business_logs()
df_user_stats = load_user_stats()

# Status do banco
if status != "OK":
    st.error(f"‚ùå {status}")
    st.info("Execute algumas opera√ß√µes na API com par√¢metro user_id para gerar logs de neg√≥cio:")
    st.code('curl "http://localhost:8080/soma/10/5?user_id=user123"')
    st.stop()

if df_logs.empty:
    st.warning("‚ö†Ô∏è Nenhum log de neg√≥cio encontrado!")
    st.stop()

# Atualizar op√ß√µes de filtro na sidebar
if not df_logs.empty:
    all_users = df_logs['user_id'].unique().tolist()
    selected_users = st.sidebar.multiselect("Usu√°rios:", options=all_users, default=all_users)

# Aplicar filtros
df_filtered = df_logs[
    (df_logs['user_id'].isin(selected_users)) &
    (df_logs['day_period'].isin(selected_periods))
].head(limit_records)

# M√©tricas principais
st.subheader("üìä M√©tricas de Neg√≥cio")
col1, col2, col3, col4, col5 = st.columns(5)

with col1:
    total_operations = len(df_logs)
    st.metric("Total de Opera√ß√µes", total_operations)

with col2:
    unique_users = df_logs['user_id'].nunique()
    st.metric("Usu√°rios √önicos", unique_users)

with col3:
    avg_result = df_logs['result_value'].mean()
    st.metric("Resultado M√©dio", f"{avg_result:.1f}")

with col4:
    most_active_user = df_logs['user_id'].value_counts().index[0]
    user_operations = df_logs['user_id'].value_counts().iloc[0]
    st.metric("Usu√°rio Mais Ativo", most_active_user, f"{user_operations} ops")

with col5:
    peak_period = df_logs['day_period'].value_counts().index[0]
    period_count = df_logs['day_period'].value_counts().iloc[0]
    st.metric("Per√≠odo de Pico", peak_period, f"{period_count} ops")

st.markdown("---")

# Tabs principais
tab1, tab2, tab3, tab4 = st.tabs(["üìä An√°lise por Usu√°rio", "‚è∞ An√°lise Temporal", "üìã Logs Detalhados", "üìà Estat√≠sticas"])

with tab1:
    col_left, col_right = st.columns(2)
    
    with col_left:
        st.subheader("üë• Opera√ß√µes por Usu√°rio")
        
        # Gr√°fico de barras - opera√ß√µes por usu√°rio
        user_counts = df_filtered['user_id'].value_counts()
        
        fig, ax = plt.subplots(figsize=(10, 6))
        bars = ax.bar(range(len(user_counts)), user_counts.values, color='lightblue', alpha=0.8)
        ax.set_xlabel('Usu√°rios')
        ax.set_ylabel('N√∫mero de Opera√ß√µes')
        ax.set_title('Opera√ß√µes por Usu√°rio')
        ax.set_xticks(range(len(user_counts)))
        ax.set_xticklabels(user_counts.index, rotation=45)
        
        # Adicionar valores nas barras
        for bar, count in zip(bars, user_counts.values):
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                    f'{count}', ha='center', va='bottom')
        
        plt.tight_layout()
        st.pyplot(fig)
        plt.close()
        
        # Top usu√°rios
        st.subheader("üèÜ Top Usu√°rios")
        for i, (user, count) in enumerate(user_counts.head(5).items(), 1):
            avg_time = df_logs[df_logs['user_id'] == user]['execution_time_ms'].mean()
            st.write(f"{i}. **{user}**: {count} opera√ß√µes (‚è±Ô∏è {avg_time:.1f}ms m√©dio)")
    
    with col_right:
        st.subheader("‚ö° Performance por Usu√°rio")
        
        # Gr√°fico de tempo m√©dio por usu√°rio
        if not df_user_stats.empty:
            fig, ax = plt.subplots(figsize=(10, 6))
            
            users = df_user_stats['user_id'].values
            avg_times = df_user_stats['avg_execution_time'].values
            
            bars = ax.bar(range(len(users)), avg_times, color='lightcoral', alpha=0.8)
            ax.set_xlabel('Usu√°rios')
            ax.set_ylabel('Tempo M√©dio (ms)')
            ax.set_title('Tempo M√©dio de Execu√ß√£o por Usu√°rio')
            ax.set_xticks(range(len(users)))
            ax.set_xticklabels(users, rotation=45)
            
            # Adicionar valores nas barras
            for bar, time_val in zip(bars, avg_times):
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                        f'{time_val:.1f}ms', ha='center', va='bottom')
            
            plt.tight_layout()
            st.pyplot(fig)
            plt.close()
        
        # Estat√≠sticas de usu√°rios
        st.subheader("üìä Resumo por Usu√°rio")
        if not df_user_stats.empty:
            display_stats = df_user_stats[['user_id', 'total_operations', 'avg_execution_time', 'total_sum_results']].copy()
            display_stats['avg_execution_time'] = display_stats['avg_execution_time'].round(2)
            display_stats.columns = ['Usu√°rio', 'Opera√ß√µes', 'Tempo M√©dio (ms)', 'Soma Total']
            st.dataframe(display_stats, use_container_width=True)

with tab2:
    col_time1, col_time2 = st.columns(2)
    
    with col_time1:
        st.subheader("üïê Distribui√ß√£o por Hora do Dia")
        
        # Gr√°fico de distribui√ß√£o por hora
        hour_counts = df_filtered['hour_of_day'].value_counts().sort_index()
        
        fig, ax = plt.subplots(figsize=(12, 6))
        ax.plot(hour_counts.index, hour_counts.values, marker='o', linewidth=2, markersize=6)
        ax.set_xlabel('Hora do Dia')
        ax.set_ylabel('N√∫mero de Opera√ß√µes')
        ax.set_title('Distribui√ß√£o de Opera√ß√µes por Hora')
        ax.set_xticks(range(0, 24, 2))
        ax.grid(True, alpha=0.3)
        
        # Destacar picos
        max_hour = hour_counts.idxmax()
        max_count = hour_counts.max()
        ax.annotate(f'Pico: {max_count} ops\n√†s {max_hour}h', 
                   xy=(max_hour, max_count), 
                   xytext=(max_hour+2, max_count+1),
                   arrowprops=dict(arrowstyle='->', color='red'))
        
        st.pyplot(fig)
        plt.close()
    
    with col_time2:
        st.subheader("üåÖ Distribui√ß√£o por Per√≠odo do Dia")
        
        # Gr√°fico de pizza - per√≠odos do dia
        period_counts = df_filtered['day_period'].value_counts()
        
        fig, ax = plt.subplots(figsize=(8, 8))
        colors = ['#FFD700', '#FF6347', '#4169E1', '#2F4F4F']  # Cores para manh√£, tarde, noite, madrugada
        wedges, texts, autotexts = ax.pie(period_counts.values, 
                                         labels=period_counts.index, 
                                         autopct='%1.1f%%',
                                         colors=colors,
                                         startangle=90)
        ax.set_title('Distribui√ß√£o por Per√≠odo do Dia')
        
        st.pyplot(fig)
        plt.close()
        
        # Estat√≠sticas temporais
        st.subheader("üìÖ Estat√≠sticas Temporais")
        st.write("**Por Per√≠odo:**")
        for period, count in period_counts.items():
            percentage = (count / len(df_filtered)) * 100
            st.write(f"‚Ä¢ {period}: {count} opera√ß√µes ({percentage:.1f}%)")

with tab3:
    st.subheader("üìã Logs de Neg√≥cio Detalhados")
    
    # Preparar dados para exibi√ß√£o
    if not df_filtered.empty:
        display_df = df_filtered.copy()
        display_df['Hor√°rio'] = display_df['timestamp'].dt.strftime('%H:%M:%S')
        display_df['Usu√°rio'] = display_df['user_id']
        display_df['Opera√ß√£o'] = display_df['input_values']
        display_df['Resultado'] = display_df['result_value']
        display_df['Tempo (ms)'] = display_df['execution_time_ms']
        display_df['Per√≠odo'] = display_df['day_period']
        display_df['IP'] = display_df['ip_address']
        display_df['Status'] = display_df['status']
        
        # Mostrar tabela
        columns_to_show = ['Hor√°rio', 'Usu√°rio', 'Opera√ß√£o', 'Resultado', 'Tempo (ms)', 'Per√≠odo', 'IP', 'Status']
        st.dataframe(display_df[columns_to_show], use_container_width=True, height=400)
        
        # Detalhes de log espec√≠fico
        st.subheader("üîç Detalhes do Log")
        
        if len(df_filtered) > 0:
            # Seletor de log
            log_options = []
            for _, row in df_filtered.iterrows():
                label = f"{row['user_id']} - {row['input_values']} = {row['result_value']} ({row['timestamp'].strftime('%H:%M:%S')})"
                log_options.append((row['id'], label))
            
            selected_log_id = st.selectbox(
                "Selecione um log:",
                options=[log[0] for log in log_options],
                format_func=lambda x: next(log[1] for log in log_options if log[0] == x)
            )
            
            if selected_log_id:
                selected_log = df_filtered[df_filtered['id'] == selected_log_id].iloc[0]
                
                detail_col1, detail_col2 = st.columns(2)
                
                with detail_col1:
                    st.write(f"**üÜî ID do Log:** {selected_log['id']}")
                    st.write(f"**üë§ Usu√°rio:** {selected_log['user_id']}")
                    st.write(f"**üìÖ Timestamp:** {selected_log['timestamp']}")
                    st.write(f"**üïê Hora:** {selected_log['hour_of_day']}h")
                    st.write(f"**üåÖ Per√≠odo:** {selected_log['day_period']}")
                    st.write(f"**üîó Operation ID:** {selected_log['operation_id']}")
                
                with detail_col2:
                    st.write(f"**‚öôÔ∏è Opera√ß√£o:** {selected_log['input_values']}")
                    st.write(f"**‚úÖ Resultado:** {selected_log['result_value']}")
                    st.write(f"**‚è±Ô∏è Tempo:** {selected_log['execution_time_ms']} ms")
                    st.write(f"**üåê IP:** {selected_log['ip_address']}")
                    st.write(f"**‚úîÔ∏è Status:** {selected_log['status']}")
                    st.write(f"**üîç Trace ID:** `{selected_log['trace_id'][:16]}...`")
                
                st.write(f"**üí¨ Mensagem:** {selected_log['message']}")

with tab4:
    st.subheader("üìà Estat√≠sticas Avan√ßadas")
    
    col_stat1, col_stat2 = st.columns(2)
    
    with col_stat1:
        st.write("**üìä Resumo Geral:**")
        st.write(f"‚Ä¢ Total de logs: {len(df_logs)}")
        st.write(f"‚Ä¢ Usu√°rios √∫nicos: {df_logs['user_id'].nunique()}")
        st.write(f"‚Ä¢ Per√≠odo mais ativo: {df_logs['day_period'].value_counts().index[0]}")
        st.write(f"‚Ä¢ Resultado m√©dio: {df_logs['result_value'].mean():.2f}")
        st.write(f"‚Ä¢ Tempo m√©dio: {df_logs['execution_time_ms'].mean():.2f} ms")
        
        st.write("**‚è∞ Por Hora:**")
        busiest_hour = df_logs['hour_of_day'].value_counts().index[0]
        busiest_count = df_logs['hour_of_day'].value_counts().iloc[0]
        st.write(f"‚Ä¢ Hora mais movimentada: {busiest_hour}h ({busiest_count} opera√ß√µes)")
        
        quietest_hours = df_logs['hour_of_day'].value_counts().tail(3)
        st.write("‚Ä¢ Horas mais calmas:")
        for hour, count in quietest_hours.items():
            st.write(f"  - {hour}h: {count} opera√ß√µes")
    
    with col_stat2:
        st.write("**üéØ An√°lise de Comportamento:**")
        
        # Usu√°rio mais produtivo
        most_productive = df_logs.groupby('user_id')['result_value'].sum().sort_values(ascending=False)
        st.write(f"‚Ä¢ Usu√°rio com maior soma total: **{most_productive.index[0]}** ({most_productive.iloc[0]})")
        
        # Usu√°rio mais r√°pido
        fastest_user = df_logs.groupby('user_id')['execution_time_ms'].mean().sort_values()
        st.write(f"‚Ä¢ Usu√°rio mais r√°pido: **{fastest_user.index[0]}** ({fastest_user.iloc[0]:.1f}ms m√©dio)")
        
        # An√°lise temporal por usu√°rio
        st.write("**üìÖ Padr√µes de Uso:**")
        user_periods = df_logs.groupby(['user_id', 'day_period']).size().unstack(fill_value=0)
        
        for user in user_periods.index[:3]:  # Top 3 usu√°rios
            preferred_period = user_periods.loc[user].idxmax()
            period_count = user_periods.loc[user].max()
            st.write(f"‚Ä¢ **{user}**: prefere {preferred_period} ({period_count} ops)")

# Rodap√©
st.markdown("---")
footer_col1, footer_col2, footer_col3 = st.columns(3)

with footer_col1:
    st.info(f"üìä √öltima atualiza√ß√£o: {datetime.now().strftime('%H:%M:%S')}")

with footer_col2:
    if st.button("üîÑ Atualizar Dados"):
        st.cache_data.clear()
        st.rerun()

with footer_col3:
    if not df_logs.empty:
        st.success(f"‚úÖ {len(df_logs)} logs de neg√≥cio carregados")

# Informa√ß√µes na sidebar
st.sidebar.markdown("---")
st.sidebar.subheader("‚ÑπÔ∏è Informa√ß√µes")
st.sidebar.write(f"**Banco:** business_logs")
st.sidebar.write(f"**Registros:** {len(df_logs) if not df_logs.empty else 0}")

if not df_logs.empty:
    first_log = df_logs['timestamp'].min()
    last_log = df_logs['timestamp'].max()
    st.sidebar.write(f"**Primeiro log:** {first_log.strftime('%H:%M:%S')}")
    st.sidebar.write(f"**√öltimo log:** {last_log.strftime('%H:%M:%S')}")